<!DOCTYPE html>
<html lang="ar">
<head>
    <meta charset="UTF-8">
    <title>Ø¬ÙˆÙ„Ø© BIM-As-built</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Ù…Ù‡Ù… Ø¬Ø¯Ø§ Ù„Ù€ GitHub Pages -->
    <base href="/BIM-As-built-sempl/">

    <link rel="stylesheet" href="style.css">

    <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>

<div id="container"></div>
<button id="autoRotateBtn">â¸ï¸ Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø¯ÙˆØ±Ø§Ù†</button>

<script>
let scenes = [];
let scene3D, camera, renderer, controls, sphereMesh;
let autoRotate = true;

fetch("tour-data.json")
.then(r => r.json())
.then(data => {
    scenes = data.scenes;

    scene3D = new THREE.Scene();

    camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1100
    );
    camera.position.set(0, 0, 0.1);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById("container").appendChild(renderer.domElement);

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.enablePan = false;
    controls.autoRotate = true;
    controls.autoRotateSpeed = 0.5;

    document.getElementById("autoRotateBtn").onclick = () => {
        autoRotate = !autoRotate;
        controls.autoRotate = autoRotate;
        document.getElementById("autoRotateBtn").textContent =
            autoRotate ? "â¸ï¸ Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø¯ÙˆØ±Ø§Ù†" : "â–¶ï¸ ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¯ÙˆØ±Ø§Ù†";
    };

    loadScene(0);
    animate();
});

function loadScene(index) {
    const data = scenes[index];
    if (!data) return;

    if (sphereMesh) scene3D.remove(sphereMesh);
    document.querySelectorAll(".hotspot").forEach(h => h.remove());

    new THREE.TextureLoader().load(
        data.image,
        texture => {
            texture.wrapS = THREE.RepeatWrapping;
            texture.repeat.x = -1;

            const geometry = new THREE.SphereGeometry(500, 128, 128);
            const material = new THREE.MeshBasicMaterial({
                map: texture,
                side: THREE.BackSide
            });

            sphereMesh = new THREE.Mesh(geometry, material);
            scene3D.add(sphereMesh);

            createHotspots(data);
        },
        undefined,
        err => console.error("âŒ ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø©:", data.image)
    );
}

function createHotspots(sceneData) {
    if (!sceneData.hotspots) return;

    sceneData.hotspots.forEach(h => {
        const pos = new THREE.Vector3(...h.position);
        pos.project(camera);

        const x = (pos.x * 0.5 + 0.5) * window.innerWidth;
        const y = (-pos.y * 0.5 + 0.5) * window.innerHeight;

        if (pos.z > 1) return;

        const div = document.createElement("div");
        div.className = "hotspot";
        div.style.left = x + "px";
        div.style.top = y + "px";
        div.innerHTML = "ğŸšª";

        div.onclick = e => {
            e.stopPropagation();
            const targetIndex = scenes.findIndex(s => s.id === h.targetId);
            if (targetIndex !== -1) loadScene(targetIndex);
        };

        document.body.appendChild(div);
    });
}

function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene3D, camera);
}

window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>
